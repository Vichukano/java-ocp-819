package ru.vichukano.ocp.oop;

/**
 * Интерфейс - в родителе может быть STATIC с той же сигнатурой
 * <p>
 * В класса СТАТИЧЕСКИЙ и НЕСТАТИЧЕСКИЙ методы с одинаковой сигнатурой объявлены не могут быть, так как статик нельзя переопределить
 */
interface Measurement {
    public static int getBreadth() {
        return 0;
    }

    public static int getHeight() {
        return 0;
    }

    public default int getLength() {
        return 0;
    }
}

interface Size extends Measurement {
    public static final int UNIT = 100;

    /**
     * Не компилируется, так как статический метод не переопределяет дефолтный метод из интерфейса родителя.
     * В интерфейсе наследнике нельзя иметь статический метод с одинаковой сигнатурой в родительском интерфейсе.
     */
    /*public static int getLength() { Не компилируется
        return 10;
    }*/

    /**
     * Работает в обратную сторону.
     * В интерфейсе наследнике может быть дефолтный или АБСТРАКТНЫЙ метод с сигнатурой статического метода
     * в интерфейсе родителе
     */
    public default int getHeight() {// Успешно компилируется
        return 1;
    }
}

/**
 * На одной линии наследования статические методы могут иметь одинаковую сигнатуру - ОБА СТАТИЧЕСКИЕ(затенение)
 * СТАТИЧЕСКИЙ и НЕСТАТИЧЕСКИЙ методы с одинаковой сигнатурой объявлены не могут быть, так как статик нельзя переопределить
 */
class A {
    //static void b() {} Не компилируется

    //void a() {} Не компилирутся
}

class B extends A {
    static void a() {
    }

    void b() {
    }
}

public class StaticMethodsAndInheritance {

}
